// first rule : receives "root"
"ruleinitial" -> {
    rule("rule_compilation_units", children("CompilationUnit"))
}

// handle with all the compilation units (files) : receives "CompilationUnit"
"rule_compilation_units" -> {
    rule("rule_compilation_unit", children)
}

// handle with each compilation unit : receives "TypeDeclaration"
"rule_compilation_unit" -> {
    "COMPILATION_UNIT" = {
        "PACKAGE_DECL" = {
            ? "NAME" = {
                "PackageDeclaration"."PackageName".child
            },
            ? "CONCRETE_UNIT_DECL" = {
                rule("rule_class_declaration", "ClassDeclaration"."NormalClassDeclaration")                
            },
            ? "INTERFACE_UNIT_DECL" = {
                rule("rule_interface_declaration", "InterfaceDeclaration"."NormalInterfaceDeclaration")
            }
        }
    }
}

// if the file contains a Java Interface, this rule has to be called : receives "NormalInterfaceDeclaration"
"rule_interface_declaration" -> {

}

// if the file contains a Class, call this rule : receives "NormalClassDeclaration"
"rule_class_declaration" -> {
    "NAME" = {
        "ClassName".child
    },
    ? "EXTENDS" = {
        "TYPE" = {
            "NAME" = {
                "Superclass"."ClassType".child
            }
        }
    },
    ? rule("rule_implements", "Superinterfaces"."InterfaceTypeList".children("InterfaceType")),
    rule ("rule_class_body", "ClassBody")
}

// handle with multiple interface implementations : receives "InterfaceType"
"rule_implements" -> {
     "IMPLEMENTS" = {
        "TYPE" = {
            "NAME" = {
                "ClassType".child
            }
        }
    }
}

// handle with all types of declaration/structures in the class body : receives "ClassBody"
"rule_class_body" -> {
    new_leaf("{"),
    ? rule("rule_class_body_declaration", children("ClassBodyDeclaration")),
    new_leaf("}")
}

// handle with each of declarations in class body : receives "ClassBodyDeclaration"
"rule_class_body_declaration" -> {
    ? rule("rule_constructor_declaration", children("ConstructorDeclaration")),
    ? rule("rule_class_member_declaration", children("ClassMemberDeclaration"))
}

// handle with constructors : receives "ConstructorDeclaration"
"rule_constructor_declaration" -> {
    "FUNCTION_DECL" = {
        "MODIFIER_LIST" = {
            ? "ConstructorModifier".child
        },
        "TYPE" = {
            new_leaf("void")
        },
        "NAME" = {
            "ConstructorDeclarator"."SimpleTypeName".child
        },
        "FORMAL_PARAM_LIST" = {
            ? rule("rule_parameter_declaration", "ConstructorDeclarator"."FormalParameterList")
        },
        "BLOCK_SCOPE" = {
            new_leaf("{"),
            ? rule("rule_block_construc_invoke", "ConstructorBody"."ExplicitConstructorInvocation"),
            ? rule("rule_block_scope", "ConstructorBody"."BlockStatements".children("BlockStatement")),            
            new_leaf("}")
        }
    }
}

// handle with fields and methods in classes : receives "ClassMemberDeclaration"
"rule_class_member_declaration" -> {
    ? rule("rule_field_declaration", "FieldDeclaration"),
    ? rule("rule_method_declaration", "MethodDeclaration")
}

// handle with each method in a class : receives "MethodDeclaration"
"rule_method_declaration" -> {

}

// handle with each field in a class : receives "FieldDeclaration"
"rule_field_declaration" -> {
    "ATTRIBUTE_DECL" = {
        "MODIFIER_LIST" = {
            ? rule("rule_field_modifier", children("FieldModifier"))
        },
        "TYPE" = {
            "UnannType".last
        },
        "NAME" = {
            "VariableDeclaratorList"."VariableDeclarator"."VariableDeclaratorId".child
        },
        "VALUE" = {
            ? "VariableInitializer".last
        }
    }    
}

// return each modifier of a field in a class : receives "FieldModifier"
"rule_field_modifier" -> {
    child
}

// handle with a list of parameters for a constructor : receives "FormalParameterList"
"rule_parameter_declaration" -> {
    ? rule("rule_formal_parameters", any children)
}

// a step to all formal parameters : receives "FormalParameters" or "LastFormalParameters"
"rule_formal_parameters" -> {
    rule("rule_formal_parameter", children("FormalParameter"))
}

// handle with each formal parameter : receives "FormalParameter"
"rule_formal_parameter" -> {
    "PARAMETER_DECL" = {
        new_leaf("MODIFIER_LIST"),
        "TYPE" = {                      
            "NAME" = {
                "UnannType".last
            }
        },
        "NAME" = {
            "VariableDeclaratorId".child
        }    
    }
}

// handle with a constructor call inside a block scope : receives "ExplicitConstructorInvocation"
"rule_block_construc_invoke" -> {
    "CONSTRUCTOR_CALL" = {
        "NAME" = {
            "ConstructorInvocationTS".child
        },
        "ARGUMENT_LIST" = {
            "SEPARATOR" = {
                new_leaf("(")
            },
            ? rule("rule_assignment_method_arguments", "ArgumentList".children("Expression")),
            "SEPARATOR" = {
                new_leaf(")")
            }
        }
    }
}

// handle with the whole block scope : receives "BlockStatement"
"rule_block_scope" -> {
    ? rule("rule_statement", child),
    ? rule("rule_local_variable_declaration_statement", child),
    new_leaf(";")
}

// handle with a block statement that does not create a new local variable : receives "Statement"
"rule_statement" -> {
    ? rule("rule_statement_without_trailing_substatement", child)
    // tem mais coisa aqui
}

// handle with a Expression statement like an Assignment for example : receives "StatementWithoutTrailingSubstatement"
"rule_statement_without_trailing_substatement" -> {
    ? rule("rule_expression_statement", child."StatementExpression")
    // tem mais coisa aqui
}

// handle with the creation of a new local variable in a block scope : receives ""
"rule_local_variable_declaration_statement" -> {

}

// handle with a Statement Expression from a StatementWithoutTrailingSubstatement : receives "StatementExpression"
"rule_expression_statement" -> {
    ? rule("rule_assignment", child),
    ? rule("rule_assignment_method_invocation", current_node.child)
    // tem mais coisa aqui
}

// handle with an Assignment Expression : receives "Assignment"
"rule_assignment" -> {
    "ASSIGNMENT_STATEMENT" = {
        "ASSIGN_OPERATOR" = {
            "AssignmentOperator".child,
            "NAME" = {
                "LeftHandSide".last
            },
            "VALUE" = {
                rule("rule_assignment_value", "Expression".last.parent.parent)
            }
        }        
    }
}

// handle with the value for an Assignment : receives ("Expression", "AdditiveExpression", or "MultiplicativeExpression").last.parent.parent
"rule_assignment_value" -> {
    ? rule("rule_assignment_value_literal", current_node),
    ? "NAME" = {
        "ExpressionName".child
    },
    ? rule("rule_assignment_method_invocation", child."MethodInvocation_lfno_primary"),
    ? rule("rule_assignment_instantiates", child."ClassInstanceCreationExpression_lfno_primary"),
    ? rule("rule_math_expression", child)
}

// handle with the order of operators for expressions : receives "Expression".last.parent
"rule_math_expression" -> {
    ? rule("rule_plus_minus_expression", "AdditiveExpression"),
    ? rule("rule_mult_div_expression", "MultiplicativeExpression")
}

// handle with a expression like x + y or x - y : receives "AdditiveExpression"
"rule_plus_minus_expression" -> {
    "OPERATOR" = {
        "MathOperatorSymbol".child,
        rule("rule_assignment_value", "AdditiveExpression".last.parent.parent),
        rule("rule_assignment_value", "MultiplicativeExpression".last.parent.parent)
    }
}

// handle with a expression like x * y or x / y : receives "MultiplicativeExpression"
"rule_mult_div_expression" -> {
    "OPERATOR" = {
        "MathOperatorSymbol".child,
        rule("rule_assignment_value", "MultiplicativeExpression".last.parent.parent),
        rule("rule_assignment_value", "UnaryExpression".last.parent.parent)
    }
}

// handle with the creation of a new instance of a class such as new X() : receives "ClassInstanceCreationExpression_lfno_primary"
"rule_assignment_instantiates" -> {
    "INSTANTIATES" = {
        "TYPE" = {
            "NAME" = {
                "MethodNameComplex".child
            }
        }
    },
    "FUNCTION_CALL" = {
        "NAME" = {
            "TYPE" = {
                "NAME" = {
                    "MethodNameComplex".child
                }
            }
        },
        "ARGUMENT_LIST" = {
            "SEPARATOR" = {
                new_leaf("(")
            },
            ? rule("rule_assignment_method_arguments", "ArgumentList".children("Expression")),
            "SEPARATOR" = {
                new_leaf(")")
            }
        }
    }
}

// handle with a constant value (literal) from an Assignment : receives variable but has a "Literal" as a child
"rule_assignment_value_literal" -> {
    "CONST" = {
        "Literal".child
    }
}

// handle with a mothod call as the value for an Assignment : receives "MethodInvocation_lfno_primary"
"rule_assignment_method_invocation" -> {
    "FUNCTION_CALL" = {
        rule("rule_assignment_method_name", current_node),
        "ARGUMENT_LIST" = {
            "SEPARATOR" = {
                new_leaf("(")
            },
            ? rule("rule_assignment_method_arguments", "ArgumentList".children("Expression")),
            "SEPARATOR" = {
                new_leaf(")")
            }
        }
    }
}

// handle with the arguments of a method call : receives "Expression"
"rule_assignment_method_arguments" -> {
    "ARGUMENT" = {
        ? rule("rule_assignment_value", last.parent.parent)
    }
}

// return the name of the method to be called : receives "MethodInvocation_lfno_primary"
"rule_assignment_method_name" -> {
    ? "NAME" = {
        "MethodName".child
    },
    ? rule("rule_assignment_method_name_complex", current_node)
}

// return a complex name of a method such as x.something() : receives "MethodInvocation_lfno_primary"
"rule_assignment_method_name_complex" -> {
    "NAME" = {
        "TypeName".child
    },
    new_leaf("."),
    "NAME" = {
        "MethodNameComplex".child
    }
}